\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

\usepackage{hyperref}
\usepackage{float}
\usepackage{booktabs}
\usepackage{abntex2cite}
%\usepackage[utf8]{inputenc}
%\usepackage{listings}
%\usepackage{lmodern}
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{indentfirst}
%\usepackage{color}
%\usepackage{graphicx}
%\usepackage{caption}
%\usepackage{subcaption}
%\usepackage{microtype}
%\usepackage{enumerate}
%\usepackage{lipsum}
%\usepackage[brazilian,hyperpageref]{backref}
%\usepackage[alf]{abntex2cite}
%\usepackage{float}
%\usepackage{amsmath}
%\usepackage{verbatim}

     
\sloppy

\title{Uma abordagem evolutiva para o problema do passeio do cavalo}

\author{Felipe Duarte dos Reis}


\address{Departamento de Computação\\
Centro Federal de Educação de Tecnológica de Minas Gerais (CEFET-MG)
}

\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  Este artigo descreve o problema do passeio do cavalo, que consiste
  em encontrar um caminho hamiltoniano em um grafo não-direcionado,
  e apresenta uma solução utilizando algoritmos genéticos.
\end{resumo}


\section{Introdução}
\label{sec:intro}
\subsection{Apresentação do problema e revisão bibliografica}

O problema do passeio do cavalo consiste em, dado um tabuleiro de xadrez
\textit{NxN}, achar uma sequencia de movimentos para um cavalo que visite
todas as posições do tabuleiro somente uma vez \cite{Wiki}. 
Um caminho que terminar com $N^2 - 1$ movimentos a um
movimento da posição de partida é chamado fechado, caso contrário ele é chamado aberto.\\
Uma possiblidade de modelagem para este problema é encontrar um caminho hamiltoniano no
grafo formado pelos possíveis movimentos de um cavalo no tabuleiro de xadrez, como na \autoref{fig:grafo}.

\begin{figure}[H]
 \centering
 \includegraphics[width=200px]{imagens/grafo.png}
 \caption{Grafo formado pelas movimentações validas do cavalo em um tabuleiro de xadrez, retirado de \citeonline{Wiki} }
 \label{fig:grafo}
\end{figure}

Diferente do modelo geral, o problema do cavalo possui solução polinomial graças a propriedades 
do grafo gerado. Existem heurísticas que tornam o problema tratável ate instâncias de no máximo \textit{76x76} \cite{Wolf}.
\citeonline{Parberry} apresenta uma solução para o problema por divisão e conquista que constrói um passeio válido 
para a maioria dos casos em $O(n^2)$. \\
O presente trabalho traz uma solução para o problema utilizando algoritmos genéticos. A seção \autoref{sec:desenvolvimento}
apresenta as principais escolhas da implementação. Os resultados de simulações computacionais 
são apresentados na seção seguinte e por fim a análise critica e conclusão.

\section{Desenvolvimento} 
\label{sec:desenvolvimento}
\subsection{Algoritmo Genético}
Um algoritmo genético é um método populacional e evolutivo para solução de problemas de otimização restrita e irrestrita.
É composto basicamente por uma população, pela função objetivo (ou função de fitness) e o conjunto de operadores.
A função objetivo é a variável de otimização do problema. Cada indivíduo, também chamados cromossomos, da população é uma solução (factível ou não)
que possúi um valor-objetivo associado, calculado pela função-objetivo. Os indivíduos podem ser dividos em partes menores chamados genes.
Um indivíduo possui uma codificação que define o tipo de dado do gene. As codificações mais comuns são binária, inteira e real.\\
Os operadores básicos do algoritmo genético são seleção, cruzamento e seleção.
O operador de seleção é responsável por, baseado em alguma regra associada ao fitness do indivíduo, selecionar indivíduos para serem cruzados.
O operador de cruzamento é responsável por, recebendo dois indivíduos pais, gerar indíviduos filhos que sejam, no mínimo factíveis.
A implementação dos operadores está fortemente atrelada à modelagem do problema e da codificação dos indivíduos.\\

\subsection{Modelo do problema e implementação}
O problema do passeio do cavalo pode ser proposto da seguinte maneira: dado um grafo $G = (V, E)$ onde $u,v \in V$ estão no conjunto de vertices 
e são casas em um tabuleiro $NxN$, numeradas da esquerda para a direita, de de cima para baixo no intervalo $[1,N^2]$. 
Alem disso, a aresta $(u,v) \in E$ se é possível movimentar um cavalo da casa $u$ até a casa $v$ de forma válida.
Uma sequencia de arestas $P$ de $u$ até $v$ é uma permutação de inteiros sem repetição $$u, ..., a_i, a_{i + 1}, ..., v$$
e é um passeio válido se e somente se $\forall (a_i, a_{i+1}) \in P, (a_i, a_{i+1}) \in E$ e $|P| = N^2-1$. \\
No presente trabalho os indivíduos foram codificados como uma permutação de inteiros como descrita acima. O valor de fitness de cada um deles
é calculado contando o número de arestas $(a_i, a_{i+1})$ que pertencem ao grafo $G$.
A operação de seleção foi implementada utilizando roleta. Para cada indivíduo é o fitness normalizado e acumulado (FNA). Um número é sorteado,
e o primeiro indivíduo que tiver FNA maior que o número é escolhido para ser pareado com o próximo indivíduo. São formados $S/2$ pares onde
$S$ é o tamanho da população. Cada par tem uma probabilidade $Cr$ de cruzar ou não.\\
O algoritmo de cruzamento utilizado foi OX. Para cada dois indivíduos pareados ele sorteia dois indices $i$ e $j$, tal que $0 \leq i \le j \leq N^2-1$
Copia para o primeiro filho a seção $[i,j]$ do primeiro pai, e para cada valor não copiado do segundo pai de $[0,N^2-1]$, ele os copia em ordem. Faz a mesma
coisa para o segundo filho, só que copiando a seção $[i,j]$ do segundo pai, e então os valores ainda não copíados do primeiro pai. Esse método cruzamento
garante que os filhos são sempre permutações válidas.\\
Uma nova população é gerada juntamente com os indivíduos da geração anterior. Todos os indivíduos tem uma probabilidade $Mt$ de sofrerem mutação em cada gene.
Para cada gene $i$, um número no intervalo $[0,1]$ é sorteado, 
se esse número for menor ou igual a $Mt$, um índice $j$ é sorteado e os genes $i$ e $j$ são trocados.\\
Por fim a população é reduzida para um tamanho $S$ novamente, selecionando os $S$ melhores indivíduos depois do cruzamento e mutação.\\
As operações de seleção, cruzamento e mutação são repetidas até que se encontre uma solução ótima ou o número máximo de iterações é atingido.\\
Apresentamos a seguir os resultados obtidos em simulações computacionais do algoritmo descrito.

\section{Resultados}
\label{sec:resultados}
Foram executadas trinta simulações para tabuleiros de tamanho 5 ate 64, como dispostos na \autoref{tab:medias}.
Os parametros utilizados foram: $Cr = 0.8$, $Mr = 0.1$, $S = 100$.
Foi definido um limite máximo de iterações para cinquenta mil (50000). O que pudemos observar foi que para nenhuma 
das instâncias do problema o algoritmo conseguiu convergir para um ótimo global. O algorimo ficou preso na grande maioria
em mínimos locais, e parou em todas as execuções pelo critério de iteração máxima e não por encontrar o ótimo global.\\
As execuções para tabuleiros de tamanho 64 duraram cerca de três horas cada, o que impossibilitou a execução de
simulações para tabuleiros maiores.

\begin{table}[H]
\centering
\begin{tabular}{*7c}
\toprule
Tamanho & \multicolumn{2}{c}{Valor mínimo} &  \multicolumn{2}{c}{Valor médio} & \multicolumn{2}{c}{Valor máximo}\\ 
\midrule
{} & mean & std & mean & std & mean & std\\ 
5  & 11.43333 & 0.620623 & 13.18567 & 0.659151 & 21.16667 & 0.833907\\ 
8  & 18.10000 & 1.241523 & 22.12233 & 1.390353 & 44.40000 & 1.566899\\ 
16 & 20.43333 & 1.165106 & 24.61667 & 1.473285 & 50.46667 & 2.096521\\ 
32 & 21.53333 & 1.306043 & 25.51167 & 1.371823 & 52.50000 & 1.408105\\ 
64 & 21.96667 & 0.999425 & 26.01333 & 1.289708 & 53.30000 & 1.417866\\ 
\bottomrule
\end{tabular}
\caption{\small{Média e desvio padrão dos valores mínimo, médio e máximo da função objetivo para diferentes tamanhos de tabuleiros}} 
\label{tab:medias}
\end{table}

Um dos motivos possíveis para a não convergência do algoritmo foi o elitismo aplicado na redução do tamanho da população,
o que faz o algoritmo ficar preso em um minimo local. É possível ver que os valores mínimos e médios também ficam muito
distantes do valor máximo encontrado pelo algoritmo. 


\section{Conclusão}
\label{sec:conclusao}
Apresentamos o

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
